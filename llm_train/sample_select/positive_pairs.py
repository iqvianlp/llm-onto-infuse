import re
import hashlib
from collections import Counter

from rapidfuzz.distance import Levenshtein

from tqdm import tqdm

from onto.load import generate_mondo_concept_synonym_set, get_parent_ids


def sanitize_text(text):
    """
    Method to sanitize the text of a synthetic definition due to boilerplate token generated by the LLM
    :param text:
    :return:
    """

    if isinstance(text, str) and len(text.strip()) > 0:
        text = text.strip().replace('"', '').replace("'", "")

        # The following list of regular expresisons useful to sanitise the text generated by the LLM can be customized
        # considering the peculiarities of each LLM.
        text = re.sub(r'<\|[^|>]*\|>', '', text)
        text = re.sub(r'(?i)Here is (?:the|a) definition(?: )?(?:of)?(?::)?', '', text)
        text = re.sub(r'(?i)Here is (?:the|a) (?:single )?sentence defining the (?:one|two|three|four|five|following) condition(?:s)?(?: )?(?::)?', '', text)
        text = re.sub(r'(?i)Here is (?:the|a) definition of the term(?: )?(?::)?', '', text)

    return text.strip()


def generate_positive_pairs_by_synonym_substitution(real_synth_definitions, ontology_dict):
    """
    Generate, for each definition the associated ones by synonym substitution
    :param real_synth_definitions: dictionary of real definitions and synthetic definitions generated by GPT-3.5-turbo
    :param ontology_dict: the onto-dictionary providing information of (MONDO) ontology concepts
    :return: dictionary with key the concept ID and value a new dictionary with:
                key the hash text of a concept definition (real or synthetic) and value a new dictionary with the following keys:
                    - 'txt': the text of the concept definition (real or synthetic)
                    - 'syn_replace': the value is a set of coupled definitions generated by concept synonym substitution
    """
    defs_syn_sub = dict()
    hash_pairs_set = set()

    # Load the set of synonyms associated to each MONDO concept
    concept_synonym_set = generate_mondo_concept_synonym_set(ontology_dict)

    # Stats counters
    stat_num_real_defs = 0
    stat_num_syns = 0
    stat_num_real_defs_extended_with_syn = 0
    stat_num_concept_syn_generated_prepending_parent_syn = 0
    stat_num_synth_defs = 0
    stat_num_synth_defs_sanitised = 0
    stat_num_synth_defs_extended_with_syn = 0

    # Adding to the concept_synonym_set the main name and synonyms specified by the CSV files with synthetic definitions
    # (synonyms of concepts that are already present in concept_synonym_set are ignored)
    for cid, label_dict in tqdm(real_synth_definitions.items(), desc=f"Adding synonyms from definitions / texts spreadsheet..."):

        if cid not in concept_synonym_set:
            concept_synonym_set[cid] = set()

        # Add main name to concept synonyms
        main_name = label_dict[list(label_dict.keys())[0]]['main_name'] if isinstance(label_dict, dict) and len(label_dict) > 0 else None
        if isinstance(main_name, str) and len(main_name.strip()) > 0:
            concept_synonym_set[cid].add(main_name.strip())

        # Add all synonyms from label_dict
        label_set = set(list(label_dict.keys()))
        concept_synonyms_lower = set([el.lower().strip() for el in concept_synonym_set[cid]])
        for lbl in label_set:
            if lbl.lower().strip() not in concept_synonyms_lower:
                concept_synonym_set[cid].add(lbl.strip())

    # Generate positive pairs for each concept, by synonym substitution
    for cid, label_dict in tqdm(real_synth_definitions.items(), desc=f"Generating positive pairs by synonym substitution..."):

        # Add cid key to result dict defs_syn_sub
        if cid not in defs_syn_sub:
            defs_syn_sub[cid] = dict()

        # Retrieve the main name and the synonyms of the concept of (MONDO) ontology with id equal to cid
        main_name = label_dict[list(label_dict.keys())[0]]['main_name'] if isinstance(label_dict, dict) and len(label_dict) > 0 else None
        concept_synonyms = concept_synonym_set[cid]

        # Get real definition of concept with id equal to cid, from the ontology, if any
        real_def = None
        for concept_label, concept_label_dict in label_dict.items():

            # Finalize iteration of all concept labels (synonyms) if already added real definition
            if isinstance(real_def, str) and len(real_def.strip()) > 0:
                break

            # Real definition: check if present and if it does not contain any synonym, extend with the synonym string
            # followed by the word "is"
            if 'real_def' in concept_label_dict and isinstance(concept_label_dict['real_def'], str) and \
                    len(concept_label_dict['real_def'].strip()) > 0 and \
                    concept_label_dict['real_def'].strip().lower() != 'none':
                real_def = concept_label_dict['real_def'].strip()
                stat_num_real_defs = stat_num_real_defs + 1

                matching_syns__real_def = set([concept_synonym for concept_synonym in concept_synonyms if re.search('(?i)(?:^|[ ;:,.])(' + re.escape(concept_synonym) + ')(?:$|[ ;:,.])', real_def) is not None])
                # In case no concept synonyms are found in the real concept definition, extend the real definitions by
                # prepending the main name of the concept or as an alternative, one of concept synonyms
                if len(matching_syns__real_def) == 0:
                    # print(f"Original REAL DEF: {real_def}")
                    concept_name = main_name.strip() if isinstance(main_name, str) and len(main_name.strip()) > 0 else list(concept_synonyms)[0]
                    real_def_new_first_char = real_def[0].lower() if real_def[0].upper() and ((real_def[1].isspace()) or (real_def[1].isalpha() and real_def[1].islower())) else real_def[0]
                    real_def = concept_name[0].upper() + concept_name[1:] + " is " + real_def_new_first_char + real_def[1:]
                    stat_num_real_defs_extended_with_syn = stat_num_real_defs_extended_with_syn + 1
                    # print(f"Extended REAL DEF: {real_def}")

        # Get synthetic definition(s) of concept with id equal to cid, synthetically generated
        synthetic_defs = set()
        for concept_label, concept_label_dict in label_dict.items():
            # Synthetic text
            if 'synth_text' in concept_label_dict and isinstance(concept_label_dict['synth_text'], str) and \
                    len(concept_label_dict['synth_text'].strip()) > 0 and \
                    concept_label_dict['synth_text'].strip().lower() != 'none':
                synth_text = concept_label_dict['synth_text'].strip()

                # Sanitize the synthetic definition
                synth_text_sanitised = sanitize_text(synth_text)
                if synth_text_sanitised != synth_text:
                    synth_text = synth_text_sanitised
                    stat_num_synth_defs_sanitised = stat_num_synth_defs_sanitised + 1

                # Extend the synthetic definition
                matching_syns__synth_def = set([concept_synonym for concept_synonym in concept_synonyms if re.search('(?i)(?:^|[ ;:,.])(' + re.escape(concept_synonym) + ')(?:$|[ ;:,.])', synth_text) is not None])
                # In case no concept synonyms are found in the synthetic concept definition, extend the synthetic
                # definitions by prepending the main name of the concept or as an alternative, one of concept synonyms
                if len(matching_syns__synth_def) == 0:
                    # print(f"Original SYNTHETIC DEF: {real_def}")
                    concept_name = main_name.strip() if isinstance(main_name, str) and len(main_name.strip()) > 0 else list(concept_synonyms)[0]
                    real_synth_new_first_char = synth_text[0].lower() if synth_text[0].upper() and ((synth_text[1].isspace()) or (synth_text[1].isalpha() and synth_text[1].islower())) else synth_text[0]
                    synth_text = concept_name[0].upper() + concept_name[1:] + " is " + real_synth_new_first_char + synth_text[1:]
                    stat_num_synth_defs_extended_with_syn = stat_num_synth_defs_extended_with_syn + 1
                    # print(f"Extended SYNTHETIC DEF: {real_def}")

                synthetic_defs.add(synth_text)
                stat_num_synth_defs = stat_num_synth_defs + 1

        # Synonym substitution: generate pairs of definitions/texts that differs with respect to the use of
        # a distinct synonym
        for def_text in [el for el in set([real_def] + list(synthetic_defs)) if isinstance(el, str) and len(el.strip()) > 0 and el.strip().lower() != "none"]:
            if def_text is not None:

                # Generate hash of definition text
                hash_txt = hashlib.md5(f"{def_text}".encode("utf")).hexdigest()
                if hash_txt not in defs_syn_sub[cid]:
                    defs_syn_sub[cid][hash_txt] = dict()
                    defs_syn_sub[cid][hash_txt]['txt'] = def_text
                    defs_syn_sub[cid][hash_txt]['syn_replace'] = set()

                # If there aren't at least two synonyms it is not possible to generate alternative definitions
                # by synonym substitution, thus an additional, novel synthetic synonym is automatically generated
                # for such concepts, by appending one of the synonyms of its parent concept to its actual synonym
                if len(concept_synonyms) == 1:
                    parent_cids = get_parent_ids(ontology_dict, cid)
                    if isinstance(parent_cids, list) and len(parent_cids) > 0 and parent_cids[0] in concept_synonym_set and len(concept_synonym_set[parent_cids[0]]) > 0:
                        concept_synonyms.add(f'{list(concept_synonym_set[parent_cids[0]])[0]} {list(concept_synonyms)[0]}')
                        stat_num_concept_syn_generated_prepending_parent_syn = stat_num_concept_syn_generated_prepending_parent_syn + 1

                # Skip concept with less than 2 synonyms
                if len(concept_synonyms) < 2:
                    print(f"Attention, the concept with id {cid} will be skipped since is characterized by "
                          f"a single synonym and cannot be used to generate positive pairs by synonym substitution....")
                    continue

                stat_num_syns = stat_num_syns + len(concept_synonyms)

                # Among all the synonyms (including the main name) of the concept with id equal to cid, identify the
                # ones that occur in the definition text and the ones that does not occur in the definition text
                matching_syns = set([concept_synonym for concept_synonym in concept_synonyms if re.search('(?i)(?:^|[ ;:,.])('+re.escape(concept_synonym)+')(?:$|[ ;:,.])', def_text) is not None])
                non_matching_syns = set([concept_synonym for concept_synonym in concept_synonyms if concept_synonym not in matching_syns])

                # print(f"DEFINITION TEXT TO PERFORM SYNONYM EXPANSION (concept id: {cid}): {txt}")
                # print(f"         |--> matching syns '{matching_syns}'")
                # print(f"         |--> NON-matching syns '{non_matching_syns}'")

                # If there are no matching synonyms (i.e. nothing to be substituted) or no non-matching synonyms
                # (i.e. nothing to substitute), skip / do not consider the text
                if len(matching_syns) == 0 or len(non_matching_syns) == 0:
                    # print(f"         |--> (is definition: {True if txt == real_def else False}) --> ATTENTION, NO MATCHING SYNONYMS!")
                    continue

                # For each non-matching synonym create a new version of the text (txt_syn_replaced) where all matching
                # synonyms are replaced by the considered non-matching synonym
                for non_matching_syn in non_matching_syns:
                    txt_syn_replaced = f'{def_text}'
                    for matching_syn in matching_syns:
                        if Levenshtein.distance(non_matching_syn, matching_syn) > 4:
                            txt_syn_replaced = re.sub('(?i)(^|[ ;:,])('+re.escape(matching_syn)+')($|[ ;:,.])', fr'\g<1>{non_matching_syn}\g<3>', txt_syn_replaced)
                            txt_syn_replaced = txt_syn_replaced.strip()
                            if txt_syn_replaced[0].lower():
                                txt_syn_replaced = txt_syn_replaced[0].upper() + txt_syn_replaced[1:]

                    # If the Levenshtein distance among the original text and the one with all matching synonyms
                    # replaced by the considered non-matching synonym is greater than 4, consider both texts as
                    # a positive pair (to be used for contrastive learning)
                    if Levenshtein.distance(def_text, txt_syn_replaced) > 4:

                        # Computed the hash of the pair of similar texts obtained by synonym substitution
                        hash_pair = hashlib.md5(f"{def_text}__{txt_syn_replaced}".encode("utf")).hexdigest()

                        if hash_pair not in hash_pairs_set:
                            defs_syn_sub[cid][hash_txt]['syn_replace'].add(txt_syn_replaced)
                            hash_pairs_set.add(hash_pair)
                            # print(f"         |--> new pair generated by synonym substitution: '{txt_syn_replaced}'")

    print(f"--------------------------------------------------------------------------------")
    print(f"INFO ON POSITIVE PAIR GENERATION BY SYNONYM EXPANSION:")
    print(f" Loaded {sum([len(dtt['syn_replace']) for c, dt in defs_syn_sub.items() for th, dtt in dt.items()])} pairs of sentences generated by synonym substitution, "
          f"spanning over {len(defs_syn_sub)} distinct concepts and {sum([len(dt) for c, dt in defs_syn_sub.items()])} real/synthetic concept definitions.")
    print(f" There are {sum([1 for c, dt in defs_syn_sub.items() if sum([1 for th, dtt in dt.items() if len(dtt['syn_replace']) == 0]) == len(dt)])} concepts "
          f"over {len(defs_syn_sub)} without any derived pair of sentences generated by synonym substitution.")
    print(f" There are {sum([1 for c, dt in defs_syn_sub.items() for th, dtt in dt.items() if len(dtt['syn_replace']) == 0])} concept definitions "
          f"over {sum([len(dt) for c, dt in defs_syn_sub.items()])} without any derived pair of sentences generated by synonym substitution.")
    print(f" Distribution of concept definitions by number of pair of sentences generated by synonym substitution: "
          f"{Counter([len(dtt['syn_replace']) for c, dt in defs_syn_sub.items() for th, dtt in dt.items()])}")
    print(f" Nuber of original definitions that have been extended with concept label: {stat_num_real_defs_extended_with_syn} over {stat_num_real_defs}")
    print(f" Nuber of concept synonym generated prepending parent concept synonym: {stat_num_concept_syn_generated_prepending_parent_syn} over {stat_num_syns}")
    print(f" Nuber of synthetic definitions that have been sanitised: {stat_num_synth_defs_sanitised} over {stat_num_synth_defs}")
    print(f" Nuber of synthetic definitions that have been extended with concept label: {stat_num_synth_defs_extended_with_syn} over {stat_num_synth_defs}")
    print(f"--------------------------------------------------------------------------------")

    return defs_syn_sub
