from collections import Counter
from typing import cast

import chromadb
from rapidfuzz.distance import Levenshtein

from tqdm import tqdm

from llm_train.sample_select.chroma_db_utils import get_chromadb_client, get_new_collection, get_collection_stats
from onto.load import get_siblings_of, get_parent_ids, get_ancestors_of, get_child_ids, get_descendants_of


def generate_hard_negative_pairs(synthetic_defs__positive_pairs, onto_d, model, chromadb_coll_name=None):
    """
    For each concept definition, retrieve hard-negative definition of distinct types. The hard-negative definitions of
    distinct types can be definitions of parents, ancestors, childrens, descendents, siblings or other concepts with
    respect to the considered concept definition.
    :param synthetic_defs__positive_pairs: set of real and synthetic definitions generated by the method
                                           llm_train.sample_select.positive_pairs.generate_positive_pairs_by_synonym_substitution
    :param onto_d: the onto-dictionary providing information of (MONDO) ontology concepts
    :param model: the sentence transformer model to be exploited to embed definition (text excerpt) to search for hard-negative pairs
    :param chromadb_coll_name: the name of the collection of Chroma DB embedding database
    :return: a dictionary with two keys:
        - 'hard_negatives_by_concept_id': dictionary with key the concept ID and values a dictionary with
                            - key the index of the considered definition in the 'text_list' list of definitions
                            - value a dictionary with the following key value pairs describing hard-negative associated to the considered definition
                                - 'siblings': hard-negative definitions of sibling concepts
                                - 'children': hard-negative definitions of children concepts
                                - 'parents': hard-negative definitions of parents concepts
                                - 'ancestors': hard-negative definitions of ancestors concepts
                                - 'descendents': hard-negative definitions of descendents concepts
                                - 'other': hard-negative definitions of other concepts (where other is none of the previous sets of concepts)
                                The values corresponding to each on of these keys are list of tuples with three eelements:
                                    - index of the paired definition in the 'text_list' list of definitions
                                    - concept ID
                                    - similarity score of the considered definition with the paired definition
        - 'text_list': list of definitions with indexes referenced by the hard_negatives_by_concept_id' dictionary
    """
    # Retrieve all concept definitions (i.e. texts) that will be indexed in the Chrooma DB embedding database
    concept_associated_texts_dict = dict()
    for cid, defs_dict in synthetic_defs__positive_pairs.items():

        if cid not in concept_associated_texts_dict:
            concept_associated_texts_dict[cid] = set()

        for def_hash, def_dict in defs_dict.items():
            if isinstance(def_dict, dict) and 'txt' in def_dict and isinstance(def_dict['txt'], str) and len(def_dict['txt'].strip()) > 0:
                concept_associated_texts_dict[cid].add(def_dict['txt'])

    print(f"----------------------------------------")
    print(f" Number of definitions / texts: {sum([len(c_defs) for cid, c_defs in concept_associated_texts_dict.items()])} over {len(concept_associated_texts_dict)} concepts.")
    print(f" Number of concepts without any definition / text: {sum([1 for cid, c_defs in concept_associated_texts_dict.items() if len(c_defs) == 0])} over {len(concept_associated_texts_dict)} concepts.")
    print(f" Distribution of number of concepts per number of definitions / texts: {Counter([len(c_defs) for cid, c_defs in concept_associated_texts_dict.items()])}.")
    print(f"----------------------------------------")

    # Create Chroma DB custom embedding function that relies on the model sentence transformer (model parameter)
    class CustomEmbeddingFunction(chromadb.EmbeddingFunction):

        def __init__(self):
            self.str = model

        def __call__(self, input: chromadb.Documents) -> chromadb.Embeddings:
            return cast(
                chromadb.Embeddings,
                self.str.encode(
                    list(input),
                    convert_to_numpy=True,
                    normalize_embeddings=False,
                    batch_size=64
                ).tolist(),
            )
    
    # Instantiate Chroma DB client and create new collection if it does not exist. Otherwise, use existing collection
    # assuming it has been already populated with all real and synthetic definition embeddings
    cdb_client = get_chromadb_client(client_sub_folder=chromadb_coll_name)
    collections_list = cdb_client.list_collections()
    found_collection = False
    for coll in collections_list:
        if coll.name == chromadb_coll_name:
            found_collection = True
            break
    
    if found_collection:
        cdb_test_coll_ref = cdb_client.get_or_create_collection(name=chromadb_coll_name, embedding_function=CustomEmbeddingFunction())
    else:
        cdb_test_coll_ref = get_new_collection(coll_name=chromadb_coll_name, embedding_function=CustomEmbeddingFunction())

        print(get_collection_stats(coll_ref=cdb_test_coll_ref))

        # Add sentence embeddings to Chroma DB
        docs = list()
        metadatas = list()
        ids = list()
        id_index = 0
        for cid, def_set in tqdm(concept_associated_texts_dict.items(), desc=f"Indexing definitions (i.e. texts) of concepts in Chroma DB..."):
            for def_el in def_set:
                if isinstance(def_el, str) and len(def_el.strip()) > 0:
                    docs.append(def_el.strip())
                    metadatas.append({"cid": f"{cid}"})
                    ids.append(f"{id_index}")
                    id_index = id_index + 1

            if len(docs) > 500:
                cdb_test_coll_ref.add(
                    documents=docs,
                    metadatas=metadatas,
                    ids=ids
                )
                docs = list()
                metadatas = list()
                ids = list()

        # Index residual docs
        if len(docs) > 0:
            cdb_test_coll_ref.add(
                documents=docs,
                metadatas=metadatas,
                ids=ids
            )
    
    # After all definition embedding have been indexed in the Chroma DB collection with name chromadb_coll_name, print
    # Chroma DB collection info
    print(get_collection_stats(coll_ref=cdb_test_coll_ref))

    # For each concept definition (real and synthetic), search for hard negatives by querying Chroma DB
    # All (real and synthetic) concept definitions are available in concept_associated_texts_dict
    hard_negatives_by_concept_id = dict()
    text_list = list()
    for cid, def_set in tqdm(concept_associated_texts_dict.items(), desc=f"Looking for hard negatives of concepts..."):

        if cid not in hard_negatives_by_concept_id:
            hard_negatives_by_concept_id[cid] = dict()

        # Retrieve sibling(s), parent(s), ancestor(s), descendent(s) and child(ren) of current concept with id
        # equal to cid
        sibling_ids = get_siblings_of(onto_d, cid)
        parents_ids = get_parent_ids(onto_d, cid)
        ancestors_ids = get_ancestors_of(onto_d, cid)
        children_ids = get_child_ids(onto_d, cid)
        descendants_ids = get_descendants_of(onto_d, cid)

        # Iterate over all the (real and synthetic) definitions associated to current concept with id equal to cid
        for def_el in def_set:
            if isinstance(def_el, str) and len(def_el.strip()) > 0:
                if f'{def_el}' not in text_list:
                    text_list.append(f'{def_el}')
                def_el_index = text_list.index(f'{def_el}')
                if def_el_index not in hard_negatives_by_concept_id[cid]:
                    hard_negatives_by_concept_id[cid][def_el_index] = dict()
                    hard_negatives_by_concept_id[cid][def_el_index]['cid'] = cid
                    hard_negatives_by_concept_id[cid][def_el_index]['txt_index'] = def_el_index

                # We try to retrieve at least 30 hard negatives of type 'other'
                hard_negatives_by_concept_id[cid][def_el_index]['other'] = list()
                top_n_to_retrieve = 300
                while len(hard_negatives_by_concept_id[cid][def_el_index]['other']) < 30:

                    if top_n_to_retrieve >= 5000:
                        print(f"CID {cid} --> Impossible to find at least 30 hard negative among the top-{top_n_to_retrieve} similar concepts - found {len(hard_negatives_by_concept_id[cid][def_el_index]['other'])} hard negatives.")
                        break

                    # Retrieved hard negative texts are categorized by the relation of the concept they describe with
                    # the current concept with id equal to cid
                    hard_negatives_by_concept_id[cid][def_el_index]['siblings'] = list()  # Most similar definitions of concepts that are SIBLINGS of the current concept with id equal to cid
                    hard_negatives_by_concept_id[cid][def_el_index]['children'] = list()  # Most similar definitions of concepts that are CHILDREN of the current concept with id equal to cid
                    hard_negatives_by_concept_id[cid][def_el_index]['parents'] = list()  # Most similar definitions of concepts that are PARENTS of the current concept with id equal to cid
                    hard_negatives_by_concept_id[cid][def_el_index]['ancestors'] = list()  # Most similar definitions of concepts that are ANCESTORS of the current concept with id equal to cid
                    hard_negatives_by_concept_id[cid][def_el_index]['descendents'] = list()  # Most similar definitions of concepts that are DESCENDENTS of the current concept with id equal to cid
                    hard_negatives_by_concept_id[cid][def_el_index]['other'] = list()  # Most similar definitions of concepts that are OF NEITHER OF THE PREVIOUS FIVE TYPES of the current concept with id equal to cid

                    if top_n_to_retrieve > 300:
                        print(f"CID {cid} --> Impossible to find at least 30 hard negative, trying with top-{top_n_to_retrieve} similar concepts...")

                    query_result = cdb_test_coll_ref.query(
                        query_texts=[def_el],
                        n_results=top_n_to_retrieve,
                        include=["documents", "metadatas", "distances"]
                        # ['embeddings', 'documents', 'metadatas', 'uris', 'data', 'distances']
                    )

                    # Increase progressively top-n nearest neighbours to retrieve up to 6000
                    if top_n_to_retrieve == 300:
                        top_n_to_retrieve = 1000
                    elif top_n_to_retrieve == 1000:
                        top_n_to_retrieve = 4999
                    elif top_n_to_retrieve == 4999:
                        top_n_to_retrieve = 6000

                    for idx, document_int in enumerate(query_result['documents'][0]):
                        cid_int = query_result["metadatas"][0][idx]['cid']

                        if cid_int != cid and Levenshtein.distance(def_el, document_int) > 4:
                            score_int = query_result["distances"][0][idx]

                            if f'{document_int}' not in text_list:
                                text_list.append(f'{document_int}')
                            document_int_index = text_list.index(f'{document_int}')

                            el_tuple = (document_int_index, cid_int, score_int)

                            if cid_int in sibling_ids:
                                hard_negatives_by_concept_id[cid][def_el_index]['siblings'].append(el_tuple)
                            elif cid_int in parents_ids:
                                hard_negatives_by_concept_id[cid][def_el_index]['parents'].append(el_tuple)
                            elif cid_int in ancestors_ids:
                                hard_negatives_by_concept_id[cid][def_el_index]['ancestors'].append(el_tuple)
                            elif cid_int in children_ids:
                                hard_negatives_by_concept_id[cid][def_el_index]['children'].append(el_tuple)
                            elif cid_int in descendants_ids:
                                hard_negatives_by_concept_id[cid][def_el_index]['descendents'].append(el_tuple)
                            else:
                                hard_negatives_by_concept_id[cid][def_el_index]['other'].append(el_tuple)

    ret_dict = dict()
    ret_dict['hard_negatives_by_concept_id'] = hard_negatives_by_concept_id
    ret_dict['text_list'] = text_list

    return ret_dict
